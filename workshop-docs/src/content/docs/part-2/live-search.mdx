---
title: Live Search Results
description: Dynamic search with debouncing as you type
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 2
---

import { Steps } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';

Wouldn't it be cool if the search results were dynamic? Results appear as you type.

You're going to make that happen now! 

## How It Works

<Steps>

1. Send search text (with debounce) to server
2. Get result list â€” titles & links
3. Repeat as search text changes

</Steps>

## Step 1: Add Dynamic Search Box

Open `templates/home.html` and replace the search-box div with HTMX-powered code:

```html title="templates/home.html" del={2-4} ins={5-10}
<div class="search-box">
    <form action="{{ url_for('search_recipes') }}" method="get">
        <input type="search" name="q" placeholder="Search recipes...">
    </form>
    <input type="search"
           name="q"
           placeholder="Search recipes..."
           hx-get="{{ url_for('search_recipes') }}"
           hx-trigger="input changed delay:300ms, search"
           hx-target="#recipe-list">
</div>
```

### Understanding the HTMX Attributes

| Attribute | Purpose |
|-----------|---------|
| `hx-get` | URL to fetch search results |
| `hx-trigger` | Fires on input change with 300ms debounce, or on search event |
| `hx-target` | Element to replace with results |

:::note[Debouncing]
The `delay:300ms` prevents sending a request on every keystroke. The request fires 300ms after the user stops typing.
:::

## Step 2: Update Server Response

Similar to before, update the server to return a **fragment** of HTML instead of a full page.

Open `app.py` and modify the search route to return only the results:

```python title="app.py" del={2} ins={3} showLineNumbers=true
def search_recipes():
    return render_template('search.html',
    return render_template('_search_results_fragment.html',
        recipe_list=results, query=query,
        page=1, total_pages=1, total_recipes=len(results))
```

<Badge text="Note" variant="note" /> Without testing for `HX-Request` header, the legacy full-page search will no longer work. 

## Step 3: Create results fragment

For the search results only, create a new template file: `templates/_search_results_fragment.html`

```html showLineNumbers title="templates/_search_results_fragment.html"
{% if query %}
<p class="search-info">
    Found {{ recipe_list|length }} result{% if recipe_list|length != 1 %}s{% endif %}
    for "{{ query }}"
</p>
{% endif %}

{% if recipe_list %}
<ul class="recipe-list">
    {% include "_recipe_list_items.html" %}
</ul>
{% elif query %}
<p class="no-results">No recipes found matching "{{ query }}"</p>
{% endif %}
```
Lines 1-6 render search info if a query term exists.
If a list of recipes exist, lines 8-12 render that list with an included fragment that is used for each recipe item.

:::tip[Houston, we have lift off!]
Try a search for `pie`. You should see dynamic search results appear automatically! 
:::

You might be wondering why there are separate templates for `recipe_list` and `recipe_list_items`. 
In the next section, that separation will be helpful for updating the ***items*** inside the list.  
