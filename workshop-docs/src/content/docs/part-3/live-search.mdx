---
title: Live Search Results with Datastar
description: Dynamic search with debouncing as you type
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 2
---

import { Steps } from '@astrojs/starlight/components';

Wouldn't it be cool if the search results were dynamic and reactive? Results appear as you type using Datastar's `@get()` action with Server-Sent Events.

You're going to make that happen now with Datastar!

## How It Works

<Steps>

1. Send search text (with debounce) to server via SSE
2. Server returns result list as HTML fragment
3. Datastar patches the DOM automatically
4. Repeat as search text changes

</Steps>

## Step 1: Add Dynamic Search Box

Open `templates/home.html` and replace the search-box div with Datastar-powered code:

```html title="templates/home.html" del={2-5} ins={6-9}
<div class="search-box">
    <form action="{{ url_for('search_recipes') }}" method="get">
        <input type="search" name="q" placeholder="Search recipes...">
        <button type="submit">Search</button>
    </form>
    <input type="search"
           name="q"
           placeholder="Search recipes..."
           data-on:input__debounce.300ms="@get('/search?q=' + evt.target.value)">
</div>
```

### Understanding the Datastar Attributes

| Attribute | Purpose |
|-----------|---------|
| `data-on:input__debounce.300ms` | Fires on input with 300ms debounce |
| `@get('/search?q=...')` | Sends SSE request with search query |
| `evt.target.value` | The current input value from the event |

:::note[Debouncing]
The `__debounce.300ms` modifier prevents sending a request on every keystroke. The request fires 300ms after the user stops typing.
:::

## Step 2: Modify Search Endpoint for SSE

Open `app.py` and modify the existing `/search` route to handle both regular requests and Datastar SSE requests:

```python title="app.py" ins={6-18} del={5}
@app.route('/search')
def search_recipes():
    """Search recipes by query text"""
    query = request.args.get('q', '').strip()
    results = recipes.search(query)

    # Render the fragment template
    html = render_template('search_results_fragment.html',
        recipe_list=results, query=query)

    # Check if this is a Datastar request (has datastar query param)
    if 'datastar' in request.args:
        def generate():
            yield SSE.patch_elements(html, selector='#recipe-list', mode='inner')
        return Response(generate(), mimetype='text/event-stream')

    # Regular HTML response
    return html
```

This approach:
- Uses a single endpoint for both Datastar SSE and regular requests
- Detects Datastar by the `datastar` query parameter it automatically adds
- Returns SSE format for Datastar, plain HTML otherwise

:::caution[Flask context]
The `render_template()` call must happen **before** the generator function runs. Inside the generator, Flask's application context is no longer available.
:::

## Step 3: Create Search Results Fragment

Create a new template file `templates/search_results_fragment.html` for the search results:

```html title="templates/search_results_fragment.html"
{% if query %}
<p class="search-info">
    Found {{ recipe_list|length }} result{% if recipe_list|length != 1 %}s{% endif %}
    for "{{ query }}"
</p>
{% endif %}

{% if recipe_list %}
<ul class="recipe-list">
    {% include "recipe_list_items.html" %}
</ul>
{% elif query %}
<p class="no-results">No recipes found matching "{{ query }}"</p>
{% endif %}
```

:::tip[Success!]
Try a search for `pie`. You should see dynamic search results appear automatically!
:::

:::note[Datastar Benefits]
- Server-driven search logic - no client-side filtering needed
- Automatic DOM patching via SSE
- Debounced input prevents excessive requests
- Same template fragments work for both HTMX and Datastar
:::
