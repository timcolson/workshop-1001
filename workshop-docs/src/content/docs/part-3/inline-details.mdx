---
title: Inline Recipe Details with Datastar
description: Display recipe details without page reloads using Datastar
---

import { Steps, Aside } from '@astrojs/starlight/components';

When a user selects a recipe, they expect to see it without delay. Viewing another recipe should not require the back button.

Displaying recipe details inline on the page, without a separate page load, would be a big improvement using Datastar's reactive approach.

**How?** You'll use Datastar's `@get()` action to fetch recipe details via Server-Sent Events (SSE) and automatically patch them into the DOM.

:::note[Good news!]
The CSS already defines styles for flex-columns, called `navigation-panel` & `details-panel`. You will use these two styles to create a two-column layout for navigation and recipe details.
:::

## Implementation overview

<Steps>
1. Install the datastar-py package
2. Add the Datastar library
3. Add two-pane layout
4. Make recipe links dynamic with Datastar
5. Create a recipe detail fragment
6. Modify recipe endpoint for SSE
</Steps>

## Step 1: Install datastar-py

The `datastar-py` package provides helper functions for generating Datastar SSE responses.

```bash
pip install datastar-py
```

## Step 2: Load Datastar library

The `layout` template is used by all pages, so it's a great place to load Datastar.

Open `templates/_layout.html` and add the script in the `<head>` section:

```html title="templates/_layout.html" ins={2-3}
<head>
    <!-- Add Datastar library -->
    <script type="module" src="https://cdn.jsdelivr.net/gh/starfederation/datastar@1.0.0-RC.7/bundles/datastar.js"></script>
</head>
```

:::caution[Important]
The `type="module"` attribute is required for Datastar to load correctly.
:::

## Step 3: Add a two-pane layout

Replace the contents of `<body>` in `_layout.html` with HTML that creates a two-column layout:

```html title="templates/_layout.html" ins={3-10} del={2}
<body>
{% block content %}{% endblock %}
<div class="container">
    <div id="recipe-navigation" class="navigation-panel">
        {% block content %}{% endblock %}
    </div>
    <div id="recipe-details" class="details-panel empty">
        <p>Select a recipe to view details</p>
    </div>
</div>
</body>
```

The `#recipe-details` div will be updated by Datastar when the SSE response arrives.

## Step 4: Make Links Dynamic

Convert the recipe link to use Datastar's `@get()` action.

Open `templates/_recipe_list_items.html` and find the recipe detail link:

```html title="Before - standard link"
<a href="{{ url_for('recipe_detail', recipe_id=recipe.index) }}">{{ recipe.index }} - {{ recipe.name }}</a>
```

Replace with Datastar-powered link:

```html title="After - Datastar enhanced" ins={2-5} del={1}
<a href="{{ url_for('recipe_detail', recipe_id=recipe.index) }}">{{ recipe.index }} - {{ recipe.name }}</a>
<a href="#" data-on:click="document.getElementById('recipe-details').classList.remove('empty');
    @get('/recipe/{{ recipe.index }}')">
    {{ recipe.index }} - {{ recipe.name }}
</a>
```

When clicked, the inline JavaScript removes the `empty` CSS class from the details panel (fixing the centered placeholder styling), then `@get()` sends a request to the existing recipe endpoint. Datastar automatically adds a `datastar` query parameter, which the server uses to detect SSE requests.

## Step 5: Create a recipe detail fragment

To send only the recipe details via SSE (without the full page layout), extract the detail HTML into its own template fragment.

**Why a fragment?** Currently, `recipe.html` is a full page — it extends `_layout.html` and includes the `<head>`, navigation, etc. When Datastar requests recipe details, you only want the recipe content itself. By extracting the details into a fragment, you can:
- Return **just the fragment** via SSE for Datastar requests (fast, partial update)
- Include the fragment in `recipe.html` for regular full-page requests (no duplication)

Create a new file `templates/_recipe_detail_fragment.html` with the recipe detail content:

```html title="templates/_recipe_detail_fragment.html"
<h1>Recipe Details: {{ recipe.name }}</h1>
<img src="{{ recipe.get_thumbnail_image_url() }}" alt="{{ recipe.name }}" width="200" height="200">

<div class="recipe-meta">
    <p><strong>Author:</strong> {{ recipe.author }}</p>
    <p>{{ recipe.description }}</p>
</div>

<div class="section">
    <h2>Ingredients</h2>
    <ul class="ingredients">
        {% for ingredient in recipe.ingredients %}
        <li>{{ ingredient }}</li>
        {% endfor %}
    </ul>
</div>

<div class="section">
    <h2>Method</h2>
    <ol class="method">
        {% for step in recipe.method %}
        <li>{{ step }}</li>
        {% endfor %}
    </ol>
</div>

<div class="source">
    <p><a href="{{ recipe.url }}" target="_blank">View original recipe source</a></p>
</div>
```

Then update `templates/recipe.html` to include the fragment instead of duplicating the content:

```html title="templates/recipe.html" ins={3} del={4}
{% block content %}

{% include "_recipe_detail_fragment.html" %}
(previous recipe detail HTML — now replaced by the include)

<hr/>
<div class="back-link">
    <a href="{{ url_for('home') }}">Back to Recipe List</a>
</div>
{% endblock %}
```

## Step 6: Modify Recipe Endpoint for SSE

Update the existing `/recipe/<id>` route to handle both regular page requests and Datastar SSE requests.

Open `app.py` and add the imports:

```python title="app.py" ins={1-2}
from flask import Response
from datastar_py import ServerSentEventGenerator as SSE
```

Then modify the existing recipe detail route:

```python title="app.py" ins={7-17} del={7}
@app.route('/recipe/<int:recipe_id>')
def recipe_detail(recipe_id):
    """Recipe detail page - returns full page or SSE fragment"""
    recipe = recipes.get_by_id(recipe_id)
    if not recipe:
        abort(404)
    return render_template('recipe.html', recipe=recipe)

    # Check if this is a Datastar request (has datastar query param)
    if 'datastar' in request.args:
        html = render_template('_recipe_detail_fragment.html', recipe=recipe)
        def generate():
            yield SSE.patch_elements(html, selector='#recipe-details', mode='inner')
        return Response(generate(), mimetype='text/event-stream')

    # Regular full page response
    return render_template('recipe.html', recipe=recipe)
```

This approach:
- Uses a single endpoint for both Datastar SSE and regular page requests
- Detects Datastar by the `datastar` query parameter it automatically adds
- Returns SSE format for Datastar, full page HTML otherwise

The `SSE.patch_elements()` helper generates the properly formatted SSE event that Datastar expects.

### Why use a generator function?

The `generate()` function uses Python's `yield` keyword, making it a generator. Flask's `Response` object accepts a generator to stream data incrementally rather than buffering the entire response in memory. This is essential for SSE because:

1. **Streaming protocol** - SSE requires the connection to stay open while events are sent over time
2. **Memory efficiency** - For longer-lived connections with multiple events, generators avoid buffering all data upfront
3. **Flask convention** - This is the standard Flask pattern for streaming responses

:::caution[Flask context]
The `render_template()` call must happen **before** the generator function runs. Inside the generator, Flask's application context is no longer available.
:::

:::tip[Success!]
You should now have dynamic loading of recipe details with Datastar!

The recipe details appear in the right panel when you click a recipe link, powered by Server-Sent Events.
:::

:::note[Datastar Advantages]
- Server-driven updates via SSE
- Automatic DOM patching - no manual JavaScript needed
- Clean separation of concerns - server renders HTML, Datastar handles updates
:::

Next up: Upgrade your app with Live Search Results using Datastar...
