---
title: Inline Recipe Details with Datastar
description: Display recipe details without page reloads using Datastar
---

import { Steps, Aside } from '@astrojs/starlight/components';

When a user selects a recipe, they expect to see it without delay. Viewing another recipe should not require the back button.

Displaying recipe details inline on the page, without a separate page load, would be a big improvement using Datastar's reactive approach.

**How?** You'll use Datastar's `@get()` action to fetch recipe details via Server-Sent Events (SSE) and automatically patch them into the DOM.

:::note[Good news!]
The CSS already defines styles for flex-columns, called `navigation-panel` & `details-panel`. You will use these two styles to create a two-column layout for navigation and recipe details.
:::

## Implementation overview

<Steps>
1. Install the datastar-py package
2. Add the Datastar library
3. Add two-pane layout
4. Make recipe links dynamic with Datastar
5. Set up SSE endpoint for recipe details
</Steps>

## Step 1: Install datastar-py

The `datastar-py` package provides helper functions for generating Datastar SSE responses.

```bash
pip install datastar-py
```

## Step 2: Load Datastar library

The `layout` template is used by all pages, so it's a great place to load Datastar.

Open `templates/layout.html` and add the script in the `<head>` section:

```html title="templates/layout.html" ins={2-3}
<head>
    <!-- Add Datastar library -->
    <script type="module" src="https://cdn.jsdelivr.net/gh/starfederation/datastar@1.0.0-RC.7/bundles/datastar.js"></script>
</head>
```

:::caution[Important]
The `type="module"` attribute is required for Datastar to load correctly.
:::

## Step 3: Add a two-pane layout

Replace the contents of `<body>` in `layout.html` with HTML that creates a two-column layout:

```html title="templates/layout.html" ins={3-10} del={2}
<body>
{% block content %}{% endblock %}
<div class="container">
    <div id="recipe-navigation" class="navigation-panel">
        {% block content %}{% endblock %}
    </div>
    <div id="recipe-details" class="details-panel">
        <p>Select a recipe to view details</p>
    </div>
</div>
</body>
```

The `#recipe-details` div will be updated by Datastar when the SSE response arrives.

## Step 4: Make Links Dynamic

Convert the recipe link to use Datastar's `@get()` action.

Open `templates/recipe_list_items.html` and find the recipe detail link:

```html title="Before - standard link"
<a href="{{ url_for('recipe_detail', recipe_id=recipe.index) }}">{{ recipe.index }} - {{ recipe.name }}</a>
```

Replace with Datastar-powered link:

```html title="After - Datastar enhanced" ins={2-4} del={1}
<a href="{{ url_for('recipe_detail', recipe_id=recipe.index) }}">{{ recipe.index }} - {{ recipe.name }}</a>
<a href="#" data-on:click="@get('/recipe/{{ recipe.index }}')">
    {{ recipe.index }} - {{ recipe.name }}
</a>
```

When clicked, `@get()` sends a request to the existing recipe endpoint. Datastar automatically adds a `datastar` query parameter, which the server uses to detect SSE requests.

## Step 5: Modify Recipe Endpoint for SSE

Update the existing `/recipe/<id>` route to handle both regular page requests and Datastar SSE requests.

Open `app.py` and add the imports:

```python title="app.py" ins={1-2}
from flask import Response
from datastar_py import ServerSentEventGenerator as SSE
```

Then modify the existing recipe detail route:

```python title="app.py" ins={7-17} del={7}
@app.route('/recipe/<int:recipe_id>')
def recipe_detail(recipe_id):
    """Recipe detail page - returns full page or SSE fragment"""
    recipe = recipes.get_by_id(recipe_id)
    if not recipe:
        abort(404)
    return render_template('recipe.html', recipe=recipe)

    # Check if this is a Datastar request (has datastar query param)
    if 'datastar' in request.args:
        html = render_template('recipe_detail_fragment.html', recipe=recipe)
        def generate():
            yield SSE.patch_elements(html, selector='#recipe-details', mode='inner')
        return Response(generate(), mimetype='text/event-stream')

    # Regular full page response
    return render_template('recipe.html', recipe=recipe)
```

This approach:
- Uses a single endpoint for both Datastar SSE and regular page requests
- Detects Datastar by the `datastar` query parameter it automatically adds
- Returns SSE format for Datastar, full page HTML otherwise

The `SSE.patch_elements()` helper generates the properly formatted SSE event that Datastar expects.

### Why use a generator function?

The `generate()` function uses Python's `yield` keyword, making it a generator. Flask's `Response` object accepts a generator to stream data incrementally rather than buffering the entire response in memory. This is essential for SSE because:

1. **Streaming protocol** - SSE requires the connection to stay open while events are sent over time
2. **Memory efficiency** - For longer-lived connections with multiple events, generators avoid buffering all data upfront
3. **Flask convention** - This is the standard Flask pattern for streaming responses

:::caution[Flask context]
The `render_template()` call must happen **before** the generator function runs. Inside the generator, Flask's application context is no longer available.
:::

:::tip[Success!]
You should now have dynamic loading of recipe details with Datastar!

The recipe details appear in the right panel when you click a recipe link, powered by Server-Sent Events.
:::

:::note[Datastar Advantages]
- Server-driven updates via SSE
- Automatic DOM patching - no manual JavaScript needed
- Clean separation of concerns - server renders HTML, Datastar handles updates
:::

Next up: Upgrade your app with Live Search Results using Datastar...
