---
title: Infinite Scroll with Datastar
description: Load more recipes automatically as user scrolls using SSE
---

import { Aside } from '@astrojs/starlight/components';
import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';

:::caution[Side Quest]
Before you add infinite scroll, you might try upgrading **Next** and **Previous** links to use Datastar.

Currently, paging reloads the whole page. The selected recipe detail gets cleared in the process.

You have the tools to fix it with Datastar! Add `data-on:click` with `@get()` to Previous/Next links, target the `#recipe-list` element, and adjust the server route to send SSE updates.

You've seen all these steps before, so you might give it a try. Doing is learning, right?
:::

Instead of a list of recipes, ten at a time, wouldn't automatic loading more recipes when the user scrolls to the bottom be better? It sure would!

With Datastar, you can use the `intersect` event combined with `@get()` to automatically load more content as the user scrolls.

Conceptually, you build automatic scrolling with the following steps:

1. Add a trigger element at the bottom of the recipe list
2. When the trigger element comes into view, send SSE request for next page
3. Server returns new recipes via SSE, replacing the trigger
4. Repeat until no more pages

You'll use Datastar attributes:

| Attribute | Purpose |
|-----------|---------|
| `data-on:intersect__once` | Fires once when element intersects viewport |
| `@get` | Sends SSE request to server |

## To add infinite scroll with Datastar

<Steps>

1. Update the recipe_list_items template

    Open `templates/recipe_list_items.html` and add the infinite scroll trigger at the end:

    ```html title="templates/recipe_list_items.html" ins={1-6}
    {% if page < total_pages %}
    <li id="load-more-trigger"
        data-on:intersect__once="@get('/recipes?page={{ page + 1 }}')">
        <span>Loading More...</span>
    </li>
    {% endif %}
    ```

2. Modify the /recipes endpoint for SSE

    The `/recipes` route already handles full page requests. Add Datastar SSE support:

    ```python title="app.py" ins={7-12}
    @app.route('/recipes')
    def list_recipes():
        """Recipe list - full page or SSE fragment"""
        page = int(request.args.get('page', 1))
        page_data = recipes.get_page(page, RECIPES_PER_PAGE)

        # Datastar SSE request (infinite scroll)
        if 'datastar' in request.args:
            html = render_template('recipe_list_items.html', **page_data)
            def generate():
                yield SSE.patch_elements(html, selector='#load-more-trigger', mode='outer')
            return Response(generate(), mimetype=SSE_MIMETYPE)

        # Regular full page request
        return render_template('home.html', **page_data)
    ```

    Note the `mode='outer'` - this replaces the entire trigger element (not just its contents) with the new recipe items plus a new trigger.

3. Remove traditional pagination

    Open `templates/recipe_list.html` and remove the pagination div:

    ```html title="templates/recipe_list.html" del={1-11}
    <div class="pagination">
        {% if page > 1 %}
        <a href="{{ url_for('list_recipes', page=page-1) }}">Previous</a>
        {% endif %}

        <span class="current">Page {{ page }} of {{ total_pages }}</span>

        {% if page < total_pages %}
        <a href="{{ url_for('list_recipes', page=page+1) }}">Next</a>
            {% endif %}
    </div>
    ```

4. Refresh the browser.

</Steps>

:::tip[Success!]
You should now have infinite scrolling with Datastar!

Scroll to the bottom and watch new recipes load automatically via Server-Sent Events.
:::

## How It Works

1. **Initial load**: Shows first 10 recipes plus a trigger element at the bottom
2. **User scrolls**: When trigger element becomes visible (`intersect__once`), Datastar sends SSE request
3. **Server responds**: New recipes HTML sent via SSE, replacing the trigger element
4. **Repeat**: New content includes a new trigger element, process continues until no more pages

:::note[Datastar Advantages]
- Server-driven pagination logic
- Real-time updates via SSE
- Clean separation of concerns
:::

You've completed all three Datastar upgrades! Head to [Next Steps](/workshop-1001/part-3/next-steps/) for a summary and instructions to try the HTMX approach.
